<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        body {
            height: auto;
            width: 60vw;
            /* to centre page on screen*/
            margin-left: auto;
            margin-right: auto;
            /* border-left: 1px solid black;
            border-right: 1px solid black; */
            padding: 2rem;
            padding-top: 3px;
            margin-top: 3rem;
            margin-bottom: 2rem;
            box-shadow: 0 0.3rem 2rem rgb(0 0 0 / 30%);
            background-color: white;
        }
        html {
            /* background-color: coral; */
        }
        </style>


</head>

<body>



    <!-- <div tabindex="-1" id="notebook" class="border-box-sizing">
        <div class="container" id="notebook-container">

            <div class="cell border-box-sizing text_cell rendered">
                <div class="prompt input_prompt">
                </div>
                <div class="inner_cell">
                    <div class="text_cell_render border-box-sizing rendered_html">
                        <h1 id="Osnovi-ra&#269;unarske-inteligencije">Osnovi ra&#269;unarske inteligencije<a
                                class="anchor-link" href="#Osnovi-ra&#269;unarske-inteligencije">&#182;</a></h1>
                        <h2 id="Ve&#382;ba-1---Pretrage">Ve&#382;ba 1 - Pretrage<a class="anchor-link"
                                href="#Ve&#382;ba-1---Pretrage">&#182;</a></h2>
                        <hr>
                        <p>U računarskim naukama, pretraga je algoritam obilaska grafa/stabla, gde je:</p>
                        <ul>
                            <li>neophodno na efikasan način obići sve čvorove grafa/stabla</li>
                            <li>neophodno od zadatog početnog čvora <strong>A</strong> pronaći put/veze do zadatog
                                krajnjeg čvora <strong>B</strong></li>
                        </ul>
                        <p>Neophodno je definisati tzv. <strong>prostor stanja pretrage</strong>, koji zapravo
                            predstavlja <em>sva moguća stanja tokom pretrage</em>. Praktično gledano, ako se pretražuje
                            graf, prostor stanja pretrage su svi čvorovi grafa. Svako stanje pretrage ima i svoje
                            <em>roditeljsko</em> stanje, odnosno stanje iz kog se došlo (npr. iz čvora A, može se otići
                            u čvorove C i F, pa A predstavlja roditeljsko stanje za stanja C i F). Pamćenje ovog
                            roditeljskog stanja je neophodno za rekonstrukciju putanje nakon pronalaska rešenja.
                            Postoji više algoritama pretraga, a razlikuju po <em>strategiji odabira sledećih
                                čvorova</em> za dalju pretragu. Neki od najčešće korišćenih su:</p>
                        <h4 id="1.-Slepe-pretrage">1. Slepe pretrage<a class="anchor-link"
                                href="#1.-Slepe-pretrage">&#182;</a></h4>
                        <p>Ovi algoritmi koriste fiksnu strategiju za odabir sledećih čvorova u pretrazi. Slepe pretrage
                            su veoma jednostavne, ali nisu pogodne za kompleksne probleme sa velikim prostorom pretrage,
                            što ih čini nepraktičnim zbog vremenskih i memorijskih ograničenja. 3 najčešće korišćene
                            slepe pretrage su:</p>
                        <ul>
                            <li>Prvi u širinu - <strong>BFS</strong> (Breadth-first search)</li>
                            <li>Prvi u dubinu - <strong>DFS</strong> (Depth-first search)</li>
                            <li>Iterativni prvi u dubinu - <strong>IDFS</strong> (Iterative depth-first search)</li>
                        </ul>
                        <h4 id="2.-Vo&#273;ene-pretrage">2. Vo&#273;ene pretrage<a class="anchor-link"
                                href="#2.-Vo&#273;ene-pretrage">&#182;</a></h4>
                        <p>Ovi algoritmi koriste <strong>heurističku funkciju</strong>, odnosno neko
                            <strong>znanje</strong> kako bi dali prednost stanjima za koja se smatra da su
                            <em>bliža</em> krajnjem stanju. Koristeći strategiju sa heuristikom, može se znatno smanjiti
                            prostor pretrage. 2 najčešće korišćene vođene pretrage su:</p>
                        <ul>
                            <li>Pohlepna pretraga / prvi najbolji - <strong>GS</strong> (Greedy/best-first search)</li>
                            <li><strong>A*</strong>- (A-star search)</li>
                        </ul>
                        <hr>
                        <p>Strategija pretrage je <strong>kompletna</strong> ako garantuje da će naći rešenje, ukoliko
                            postoji.</p>
                        <p>Strategija pretrage je <strong>optimalna</strong> ako garantuje da će pronaći najbolje moguće
                            rešenje, ukoliko postoji više rešenja.</p>
                        <hr>
                        <h2 id="Slepe-pretrage">Slepe pretrage<a class="anchor-link" href="#Slepe-pretrage">&#182;</a>
                        </h2>
                        <h3 id="Prvi-u-&#353;irinu---BFS-(Breadth-first-search)">Prvi u &#353;irinu - BFS (Breadth-first
                            search)<a class="anchor-link"
                                href="#Prvi-u-&#353;irinu---BFS-(Breadth-first-search)">&#182;</a></h3>
                        <p>Pretraga prvi u širinu počinje od početnog čvora i razvija <em>sve</em> sledeće čvorove
                            (čvorove na prvom nivou), pa onda njihove sledeće čvorove (čvorove na drugom nivou), itd.
                            (struktura reda - queue). Znači da se svi čvorovi na nivou n razvijaju pre čvorova na nivou
                            n+1. Pošto BFS iscrpno razvija sve čvorove na određenoj dubini pre nego što razvije čvorove
                            na sledećoj dubini, garantovano je da će naći rešenje, kao i da će to rešenje biti najbolje
                            moguće. Glavna mana je visoka memorijska zahtevnost - u najgorem slučaju <em>svi</em>
                            čvorovi u grafu će biti u memoriji.</p>
                        <p><img src="img/bfs.gif" alt="img/bfs.gif"></p>
                        <h3 id="Prvi-u-dubinu---DFS-(Depth-first-search)">Prvi u dubinu - DFS (Depth-first search)<a
                                class="anchor-link" href="#Prvi-u-dubinu---DFS-(Depth-first-search)">&#182;</a></h3>
                        <p>Pretraga prvi u dubinu počinje od početnog čvora i razvija prvi neposredni čvor, zatim prvi
                            neposredni od tog čvora, i tako dok ne dođe do čvora koji nema narednih čvorova (struktura
                            steka - stack). Tek kada dođe do terminalnog čvora, vraća se u prethodni čvor i istražuje
                            drugi neposredni čvor (tzv. "backtrack"). DFS razvija jednu granu stabla dok ne stigne do
                            terminalnog čvora, pre nego što pređe na razvoj sledeće grane. Za razliku od BFS, DFS ne
                            garantuje optimalno rešenje. Takođe, postoji mogućnost da će razvijati beskonačno dugačku
                            granu (što je moguće u beskonačnim grafovima) i neće se nikad vratiti da ispita druge grane,
                            i samim tim neće naći rešenje, čak i ako postoji. Ipak, memorijske zahtevnosti DFS su daleko
                            manje od BFS, jer je nephodno da se u memoriji čuva samo trenutna putanja pretrage.</p>
                        <p><img src="img/dfs.gif" alt="img/dfs.gif"></p>
                        <h3 id="Iterativni-prvi-u-dubinu---IDFS-(Iterative-depth-first-search)">Iterativni prvi u dubinu
                            - IDFS (Iterative depth-first search)<a class="anchor-link"
                                href="#Iterativni-prvi-u-dubinu---IDFS-(Iterative-depth-first-search)">&#182;</a></h3>
                        <p>Ova pretraga u svakoj iteraciji postavlja ograničenje na dubinu do koje se onda primenjuje
                            pretraga prvi u dubinu. Ukoliko se rešenje ne pronađe na toj dubini, u sledećoj iteraciji se
                            povećava ograničenje i pokušava se ponovo. IDFS kombinuje prednosti BFS i DFS - kontinualnim
                            povećavanjem ograničenja na dubinu dok se ne nađe rešenje, IDFS ima snagu BFS po pitanju
                            optimalnosti. A pošto se koristi DFS u svakoj iteraciji, IDFS izbegava memorijsku zahtevnost
                            BFS.</p>
                        <p><img src="img/idfs.gif" alt="img/idfs.gif"></p>
                        <h2 id="Vo&#273;ene-pretrage">Vo&#273;ene pretrage<a class="anchor-link"
                                href="#Vo&#273;ene-pretrage">&#182;</a></h2>
                        <h3 id="Pohlepna-pretraga---GS-(Greedy-search)">Pohlepna pretraga - GS (Greedy search)<a
                                class="anchor-link" href="#Pohlepna-pretraga---GS-(Greedy-search)">&#182;</a></h3>
                        <p>Svako stanje u pretrazi se ocenjuje heurističkom funkcijom <strong>f(n) = h(n)</strong>, koja
                            procenjuje koliko je stanje "blizu" krajnjem stanju. Uvek se prvo istražuje ono stanje za
                            koje se smatra da je najbliže krajnjem. Efikasnost ove strategije umnogome zavisi od same
                            heurističke funkcije - od nje zavisi da li je GS strategija kompletna i optimalna.</p>
                        <p><img src="img/gs.gif" alt="img/gs.gif"></p>
                        <h3 id="A*---(A-star-search)">A* - (A-star search)<a class="anchor-link"
                                href="#A*---(A-star-search)">&#182;</a></h3>
                        <p>Ova strategija pretrage, kao i GS, koristi heurističku funkciju kao vodilju. Međutim, za
                            razliku od GS, A* proširuje heurističku funkciju sa postojećom cenom od početnog stanja do
                            trenutnog stanja, odnosno <strong>f(n) = g(n) + h(n)</strong>, gde je <strong>g(n)</strong>
                            cena od početnog stanja do trenutnog stanja. Za razliku od GS, A* je kompletna strategija
                            pretrage. Kako bi A* bila i optimalna, mora biti korišćena sa prihvatljivom heuristikom.
                            Prihvatiljiva heuristika, poznata i kao optimistička heuristika, nikad ne precenjuje cenu
                            dostizanja krajnjeg stanja.</p>
                        <p><img src="img/astar.gif" alt="img/astar.gif"></p>
                        <hr>

                    </div>
                </div>
            </div>
            <div class="cell border-box-sizing text_cell rendered">
                <div class="prompt input_prompt">
                </div>
                <div class="inner_cell">
                    <div class="text_cell_render border-box-sizing rendered_html">
                        <h2 id="Berkeley-Pacman-projekat">Berkeley Pacman projekat<a class="anchor-link"
                                href="#Berkeley-Pacman-projekat">&#182;</a></h2>
                        <hr>
                        <h3 id="O-projektu">O projektu<a class="anchor-link" href="#O-projektu">&#182;</a></h3>
                        <p>U ovom projektu, vaš Pacman agent treba da pronađe odgovarajuću putanju kroz lavirint. Njegov
                            zadatak je da dostigne određenu lokaciju i da uz to na efikasan način pokupi hranu koja se
                            nalazi usput. Odvedite Pacmana do cilja uz pomoć gore objašnjenih algoritama. Vaš zadatak je
                            da implementirate algoritme pretrage, kojima će se Pacman kretati po lavirintu.</p>
                        <p>Kod ovog projekta se sastoji iz više python datoteka. Datoteke u kojima se nalaze zadaci su:
                        </p>
                        <ul>
                            <li><code>search.py</code> </li>
                            <li><code>searchAgents.py</code> </li>
                        </ul>
                        <hr>
                        <h3 id="Pokretanje-projekta">Pokretanje projekta<a class="anchor-link"
                                href="#Pokretanje-projekta">&#182;</a></h3>
                        <p>Pozicionirajte se u folder projekta (v1-pretrage/src). Ukoliko želite da igrate Pacman igru,
                            projekat se pokreće komandom</p>

                        <pre><code>python pacman.py</code></pre>
                        <p>Najjednostavniji agent u datoteci searchAgents.py je GoWestAgent, koji uvek ide ka ”zapadu”
                            (na levo). Ovaj agent može samo u nekim slučajevima da pobedi igru.</p>

                        <pre><code>python pacman.py --layout testMaze --pacman GoWestAgent</code></pre>
                        <p>Međutim, ovaj agent nije baš najbolji kada je potrebno napraviti skretanje:</p>

                        <pre><code>python pacman.py --layout tinyMaze --pacman GoWestAgent</code></pre>
                        <p>Ako se vaš Pacman agent zaglavi, uvek možete prekinuti igru tako što ćete ukucati CTRL+C u
                            komandnoj liniji iz koje ste pokrenuli projekat.</p>
                        <p><code>pacman.py</code> podržava veliki broj opcija, koje mogu da se iskažu na duži
                            (<code>--layout</code>), ili kraći (<code>--l</code>) način. Sve komande koje je moguće
                            izvršiti nalaze se u datoteci <code>command.txt</code> u ovom projektu
                            (<code>src/commands.txt</code>).</p>

                    </div>
                </div>
            </div>
            <div class="cell border-box-sizing text_cell rendered">
                <div class="prompt input_prompt">
                </div>
                <div class="inner_cell">
                    <div class="text_cell_render border-box-sizing rendered_html">
                        <h2 id="Zadaci">Zadaci<a class="anchor-link" href="#Zadaci">&#182;</a></h2>
                        <h3 id="Slepe-pretrage">Slepe pretrage<a class="anchor-link" href="#Slepe-pretrage">&#182;</a>
                        </h3>
                        <p><strong>TODO 1</strong>: U <code>searchAgents.py</code> možete pronaći u potpunosti
                            implementiranog SearchAgent-a, koji prvo planira svoj put kroz svet Pacman-a, a zatim ga i
                            izvršava korak po korak. Isprobajte da li agent uspešno radi pozivom komande:</p>

                        <pre><code>python pacman.py -l tinyMaze -p SearchAgent -a fn=tinyMazeSearch</code></pre>
                        <p>Komanda koju ste upravo izvršili govori SearchAgent-u da iskoristi tinyMazeSearch kao
                            algoritam pretrage, kako bi isplanirao i prešao svoju putanju do cilja. Ovaj algoritam
                            implementiran je u datoteci <code>search.py</code>. Trebalo bi da, nakon pokretanja, Pacman
                            uspešno pređe svoju putanju kroz lavirint.
                            Vaš zadatak je da sada implementirate pretragu prvi u dubinu (DFS) u datoteci
                            <code>search.py</code> (funkcija <code>depthFirstSearch</code>), kojom će se SearchAgent
                            služiti kako bi prešao putanju kroz lavirint do cilja.
                            Vaše rešenje testirajte na sledeće načine:</p>
                        <p><code>python pacman.py -l tinyMaze -p SearchAgent</code></p>
                        <p><code>python pacman.py -l mediumMaze -p SearchAgent</code></p>
                        <p><code>python pacman.py -l bigMaze -z .5 -p SearchAgent</code></p>
                        <p>Pacman tabla će prikazati sva stanja koja je agent istražio, kao i redosled u kojem ih je
                            istražio (svetlije crvena boja označava ranije stanje).</p>
                        <ul>
                            <li>Napomena 1: Sve funkcije pretrage koje implementirate treba da vrate listu akcija, koje
                                će voditi agenta od starta do cilja. Ove akcije treba da budu validni pokreti (npr.
                                agent ne sme da prolazi kroz zidove u lavirintu).</li>
                            <li>Napomena 2: Koristite strukture podataka <code>Stack.py</code>,
                                <code>PriorityQueue.py</code> i <code>Queue.py</code>, koje su implementirane u datoteci
                                <code>util.py</code>.</li>
                        </ul>
                        <p><strong>TODO 2</strong>: Implementirajte pretragu prvi u širinu (BFS) u datoteci
                            <code>search.py</code> (funkcija <code>breadthFirstSearch</code>). Vaše rešenje testirajte
                            na isti način kao za DFS:</p>
                        <p><code>python pacman.py -l mediumMaze -p SearchAgent -a fn=bfs</code></p>
                        <p><code>python pacman.py -l bigMaze -p SearchAgent -a fn=bfs -z .5</code></p>
                        <ul>
                            <li>Napomena: Ako ste napisali dovoljno generično rešenje, Vaš kod bi trebalo jednako dobro
                                da radi i za eight-puzzle-search problem, bez ikakve izmene.ž</li>
                        </ul>
                        <p><code>python eightpuzzle.py</code></p>
                        <hr>
                        <h5 id="Vo&#273;ene-pretrage">Vo&#273;ene pretrage<a class="anchor-link"
                                href="#Vo&#273;ene-pretrage">&#182;</a></h5>
                        <p><strong>TODO 3</strong>: Implementirajte A* pretragu u datoteci <code>search.py</code>
                            (funkcija <code>aStarSearch</code>). A* kao parametar prima heurističku funkciju. Heuristika
                            ima dva argumenta: stanje u problemu pretrage (glavni argument) i sam problem (kao
                            referencu). Funkcija <code>nullHeuristic</code> u datoteci <code>search.py</code> je
                            trivijalan primer heurističke funkcije.
                            Vašu A* implementaciju možete testirati na originalnom problemu pronalaženja putanje kroz
                            lavirint do fiksne pozicije, koristeći Manhattan distance heuristiku, koja je već
                            implementirana u datoteci <code>search.py</code> u funkciji <code>manhattanHeuristic</code>.
                            Pokrenite rešenje na sledeći način:</p>
                        <p><code>python pacman.py -l bigMaze -z .5 -p SearchAgent -a fn=astar,heuristic=manhattanHeuristic</code>
                        </p>
                        <hr>

                    </div>
                </div>
            </div>
        </div>
    </div> -->





</body>

</html>